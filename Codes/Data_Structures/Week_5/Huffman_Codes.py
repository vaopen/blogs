'''
# Huffman Codes
In 1953, David A. Huffman published his paper "A Method for the Construction of
Minimum-Redundancy Codes", and hence printed his name in the history of computer
science. As a professor who gives the final exam problem on Huffman codes, I am
encountering a big problem: the Huffman codes are NOT unique. For example, given
a string "aaaxuaxz", we can observe that the frequencies of the characters 'a',
'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols
as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001,
'z'=000}, both compress the string into 14 bits. Another set of code can be given
as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is
NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code
00001011001001. The students are submitting all kinds of codes, and I need a
computer program to help me determine which ones are correct and which ones
are not.
# Input Specification:
Each input file contains one test case. For each case, the first line gives an
integer N (2≤N≤63), then followed by a line that contains all the N distinct
characters and their frequencies in the following format:
```
c[1] f[1] c[2] f[2] ... c[N] f[N]
```
where c[i] is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'},
and f[i] is the frequency of c[i] and is an integer no more than 1000. The next
line gives a positive integer M (≤1000), then followed by M student submissions.
Each student submission consists of N lines, each in the format:
```
c[i] code[i]
```
where c[i] is the i-th character and code[i] is an non-empty string of no more
than 63 '0's and '1's.
# Output Specification:
For each test case, print in each line either "Yes" if the student's submission
is correct, or "No" if not.

Note: The optimal solution is not necessarily generated by Huffman algorithm.
Any prefix code with code length being optimal is considered correct.
# Sample Input:
```
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
```
# Sample Output:
```
Yes
Yes
No
No
```
# Test Input:
```
8
A 1 B 1 C 1 D 1 E 1 F 1 G 1 H 1
1
A 000
B 001
C 010
D 011
E 100
F 101
G 110
H 111
```
'''
class Node():
    def __init__(self, weight, data=None):
        self.weight = weight
        self.data = data
        self.height = 0
        self.left = None
        self.right = None

class Heap():
    def __init__(self):
        self.heap = [Node(-1)]

    def insert(self, node):
        index = len(self.heap)
        # print(index)
        self.heap.append(node)
        while self.heap[index].weight < self.heap[index//2].weight:
            # print(node.data + str(node.weight))
            self.heap[index], self.heap[index//2] = self.heap[index//2], self.heap[index]
            index = index//2

    def delete(self):
        top = self.heap[1]
        self.heap[1] = self.heap[len(self.heap)-1]
        self.heap = self.heap[:-1]
        p = 1
        while (p*2<len(self.heap)):
            child = p*2
            if (child+1<len(self.heap)) and (self.heap[child].weight > self.heap[child+1].weight):
                child += 1
            if self.heap[child].weight < self.heap[p].weight:
                self.heap[child], self.heap[p] = self.heap[p], self.heap[child]
            else:
                break
            p = child
        return top

def isPrefixCode(codes):
    root = Node(0)
    flag = True
    for k in codes:
        t = root
        for n in range(len(codes[k])):
            if t.data:
                flag = False
                break
            if codes[k][n] == '0':
                if not t.left:
                    t.left = Node(0)
                elif n == len(codes[k])-1:
                    flag = False
                    break
                t = t.left
            else:
                if not t.right:
                    t.right = Node(0)
                elif n == len(codes[k])-1:
                    flag = False
                    break
                t = t.right
            if n == len(codes[k])-1:
                t.data = True
        if not flag:
            break
    return flag
'''
    flag = True
    for k1,v1 in codes.items():
        for k2,v2 in codes.items():
            if (k1 == k2) or (len(v1)>len(v2)):
                continue
            else:
                if v2[:len(v1)] == v1:
                    flag = False
                    break
        if not flag:
            break
    return flag
'''

def levelOrderTraversal(tree):
    heights = {}
    stack = []
    stack.append(tree)
    tree.height = 0
    while stack:
        t = stack.pop()
        if t.left:
            t.left.height = t.height+1
            t.right.height = t.height+1
            stack.append(t.left)
            stack.append(t.right)
        else:
            heights[t.data] = t.height
    # print(heights)
    return heights

heap = Heap()
num = eval(input())
datas = input().split(' ')
weights = {}
for i in range(num):
    # print(list(map(lambda x:str(x.data)+':'+str(x.weight),heap.heap)))
    heap.insert(Node(int(datas[2*i+1]), datas[2*i]))
    weights[datas[2*i]] = int(datas[2*i+1])

'''将堆内各结点组织成一棵Huffman树'''
while len(heap.heap) > 2:
    # print(list(map(lambda x:str(x.data)+':'+str(x.weight),heap.heap)))
    n1 = heap.delete()
    n2 = heap.delete()
    n = Node(n1.weight + n2.weight)
    n.left = n1
    n.right = n2
    heap.insert(n)

'''计算Huffman树的WPL'''
WPL = 0
for k, v in levelOrderTraversal(heap.heap[1]).items():
    WPL += weights[k] * v
# WPL /= sum(weights.values())
# print(WPL)

'''判断各编码是否满足条件'''
for i in range(int(input())):
    codes = {}
    flag = True
    for j in range(num):
        k = input().split(' ')
        codes[k[0]] = k[1]
    # print(flag)
    '''计算WPL'''
    wpl = 0
    for k, v in codes.items():
        wpl += weights[k] * len(v)
    # wpl /= sum(weights.values())
    # print(wpl)
    flag = flag and (wpl==WPL)
    '''判断是否为前缀码'''
    flag = flag and isPrefixCode(codes)
    if flag:
        print('Yes')
    else:
        print('No')
